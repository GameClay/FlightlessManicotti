from SCons.Util import flatten
import os
import sys

Import('env')
lib_env = env.Clone()
bin_env = env.Clone()

#lib_env.Replace(CC = "clang")

lib_env.Append(SWIGFLAGS=['-lua'])
###
def build_my_header(target, source, env):
   t_name = str(target[0])
   
   # Auto-generate header for swig files
   swig_hdr = open(t_name, "w")

   swig_hdr.write("#ifndef _SWIG_AUTOGEN_H_\n")
   swig_hdr.write("#define _SWIG_AUTOGEN_H_\n")

   for f in source:
      (dirName, fileName) = os.path.split(str(f))
      (fileBaseName, fileExtension)=os.path.splitext(fileName)
      swig_hdr.write("extern int luaopen_" + fileBaseName + "(lua_State* L);\n")

   swig_hdr.write("\n#define LOAD_SWIG_LIBS(L) {\\\n");
   for f in source:
      (dirName, fileName) = os.path.split(str(f))
      (fileBaseName, fileExtension)=os.path.splitext(fileName)
      swig_hdr.write("luaopen_" + fileBaseName +"(L);\\\n") 

   swig_hdr.write("}\n\n")
   swig_hdr.write("#endif // _SWIG_AUTOGEN_\n")
   swig_hdr.close()
###

excluded_files = []

# Files used to create the binary
executable_files = ['example/main.cpp']
executable_files = [f for f in executable_files if f not in excluded_files]

# Files used for shared library which binary requires
core_files = Glob('runtime/core/*.c', strings=True)
c1x_files = Glob('lib/C1x/*.c', strings=True)
script_files = Glob('runtime/script/*.c', strings=True) + Glob('runtime/script/modules/*.c', strings=True)
swig_files = Glob('runtime/script/swig/*.i', strings=True)

# Autogenerated header for swig static modules
lib_env.Command("swig_autogen.h", swig_files, build_my_header)

# Assemble the runtime lib source files
lib_files = core_files + c1x_files + script_files + swig_files

# Prune out omitted files
lib_files = [f for f in lib_files if f not in excluded_files]     # Omit excluded files
lib_files = [f for f in lib_files if f not in executable_files]   # Omit executable source files


# Bring in additional standard  C requirements

# Nobody supports C1x yet, so include this by default.
additional_std_lib_includes = ['std/C1x']

# TODO: Change this to Visual Studio, and check by-version
if (sys.platform == 'win32' or sys.platform == 'cygwin'):
    additional_std_lib_includes += ['std/C99']

# Dependencies of the runtime lib
lib_src_dir = 'runtime/lib/'
    
runtime_lib_includes = [
   lib_src_dir + 'amp/src/c',
   lib_src_dir + 'lua/src',
   lib_src_dir + 'nedmalloc',
   lib_src_dir + 'MicroAllocator'
]

runtime_lib_paths = [
   lib_src_dir + 'lua/.build',
   lib_src_dir + 'amp/.build',
   lib_src_dir + 'MicroAllocator/.build',
   lib_src_dir + 'nedmalloc/x86/Release'
]

# Build runtime library
lib_env.Append(CPPDEFINES=['KL_BUILD_LIBRARY'])
core_lib = lib_env.SharedLibrary('FlightlessManicotti', 
	lib_files,
	CPPPATH = ['.','runtime'] + runtime_lib_includes + additional_std_lib_includes,
	CCFLAGS = ['-g','-std=c99'],
	LIBS=['amp','lua','nedmalloc','MicroAllocator','libstdc++'], 
	LIBPATH=['.'] + runtime_lib_paths
)

executable = bin_env.Program('FlightlessManicotti',
   executable_files,
   CPPPATH = ['runtime'] + additional_std_lib_includes,
   CXXFLAGS = ['-g'],
   LIBS=['FlightlessManicotti'], 
   LIBPATH=['.']
)
bin_env.Requires(executable, core_lib)

Return(['core_lib', 'executable'])