<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>FlightlessManacotti: runtime/src/thirdparty/amp/src/c/amp/amp_barrier.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>runtime/src/thirdparty/amp/src/c/amp/amp_barrier.h File Reference</h1>  </div>
</div>
<div class="contents">
<code>#include &lt;stddef.h&gt;</code><br/>
<code>#include &lt;<a class="el" href="amp__memory_8h_source.html">amp/amp_memory.h</a>&gt;</code><br/>

<p><a href="amp__barrier_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="amp__barrier_8h.html#ab46fdbe8eb225372d6b328b6e3669999">AMP_BARRIER_UNINITIALIZED</a>&nbsp;&nbsp;&nbsp;NULL</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="amp__barrier_8h.html#ab50e6f740d1117c37b81cbc620df70ee">AMP_BARRIER_SERIAL_THREAD</a>&nbsp;&nbsp;&nbsp;((int)-1)</td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="amp__barrier_8h.html#a21139b66bd4e412ec69d146dc1dd4a57">amp_barrier_count_t</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="amp__barrier_8h.html#a18df16c126bb25fb0aabe4c55fe56991">amp_barrier_create</a> (amp_barrier_t *barrier, amp_allocator_t allocator, <a class="el" href="amp__barrier_8h.html#a21139b66bd4e412ec69d146dc1dd4a57">amp_barrier_count_t</a> init_count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="amp__barrier_8h.html#a63404b4fba61ed3feffaf3e24725cdd1">amp_barrier_destroy</a> (amp_barrier_t *barrier, amp_allocator_t allocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="amp__barrier_8h.html#ab8fdfd8c2b41e4d557fdcdc51f68b4a9">amp_barrier_wait</a> (amp_barrier_t barrier)</td></tr>
</table>
<hr/><a name="_details"></a><h2> </h2>
<p>Simple thread barrier which is created with a specified numbers of threads which need to wait on the barrier concurrently to be able to pass it all together. Every thread waiting on the barrier decreases an internal counter. When that counter reaches zero the barrier is fulfilled and all threads are unblocked to proceed. One and only one thread will get a return value of AMP_BARRIER_SERIAL_THREAD from the waiting function. This can be used for example in the following case where all other threads enter the next barrier immediately after passing a preceeding one while the thread receiving the special return value from wait prepares some data by its own and then enters the next barrier, too, so all threads can compute on the prepared data.</p>
<p>TODO:</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>Decide if to add a function to trywait if a barrier would be left by waiting on it. Do this via a register/unregister trywait functionality so the barrier can internally count if the already waiting threads and the one who registerd for trywait would be enought to resolve and leave the barrier.</dd></dl>
<p>TODO:</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>The moment hardware supports it add a barrier type that is only valid for a group of cores - think OpenCL workgroup barriers. </dd></dl>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ab50e6f740d1117c37b81cbc620df70ee"></a><!-- doxytag: member="amp_barrier.h::AMP_BARRIER_SERIAL_THREAD" ref="ab50e6f740d1117c37b81cbc620df70ee" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AMP_BARRIER_SERIAL_THREAD&nbsp;&nbsp;&nbsp;((int)-1)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>After the number of threads a barrier waits for reached the barrier it unblocks all of them and returns AMP_SUCCESS while exactly one thread receives the value AMP_BARRIER_SERIAL_THREAD.</p>
<p>This thread could then do some preparation work while all others wait on the next barrier that guards the start of the next parallel computations done by all threads. </p>

</div>
</div>
<a class="anchor" id="ab46fdbe8eb225372d6b328b6e3669999"></a><!-- doxytag: member="amp_barrier.h::AMP_BARRIER_UNINITIALIZED" ref="ab46fdbe8eb225372d6b328b6e3669999" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AMP_BARRIER_UNINITIALIZED&nbsp;&nbsp;&nbsp;NULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a21139b66bd4e412ec69d146dc1dd4a57"></a><!-- doxytag: member="amp_barrier.h::amp_barrier_count_t" ref="a21139b66bd4e412ec69d146dc1dd4a57" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned int <a class="el" href="amp__barrier_8h.html#a21139b66bd4e412ec69d146dc1dd4a57">amp_barrier_count_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Type of the barrier counter. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a18df16c126bb25fb0aabe4c55fe56991"></a><!-- doxytag: member="amp_barrier.h::amp_barrier_create" ref="a18df16c126bb25fb0aabe4c55fe56991" args="(amp_barrier_t *barrier, amp_allocator_t allocator, amp_barrier_count_t init_count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int amp_barrier_create </td>
          <td>(</td>
          <td class="paramtype">amp_barrier_t *&nbsp;</td>
          <td class="paramname"> <em>barrier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">amp_allocator_t&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="amp__barrier_8h.html#a21139b66bd4e412ec69d146dc1dd4a57">amp_barrier_count_t</a>&nbsp;</td>
          <td class="paramname"> <em>init_count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates and initializes barrier setting its counter to init_count.</p>
<p>The platfrom backend functions to create the internals of the barrier might not go through the allocator provided but might call malloc directly.</p>
<p>init_count must be greater than 0.</p>
<p>If the initialization fails the allocator is called to free the already allocated memory which must not result in an error or otherwise behavior is undefined.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>AMP_SUCCESS on successful creation and initialization of barrier. AMP_NOMEM is returned if not enough memory is avaible. AMP_UNSUPPORTED is returned if barriers aren't supported. Other error codes might be returned to signal errors while creating, too. These are programming errors and mustn't occur in release code. When <em>amp</em> is compiled without NDEBUG set it might assert that these programming errors don't happen. AMP_ERROR is returned if arguments are invalid or if not enough platform resources exist to create the barrier internals. </dd></dl>

</div>
</div>
<a class="anchor" id="a63404b4fba61ed3feffaf3e24725cdd1"></a><!-- doxytag: member="amp_barrier.h::amp_barrier_destroy" ref="a63404b4fba61ed3feffaf3e24725cdd1" args="(amp_barrier_t *barrier, amp_allocator_t allocator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int amp_barrier_destroy </td>
          <td>(</td>
          <td class="paramtype">amp_barrier_t *&nbsp;</td>
          <td class="paramname"> <em>barrier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">amp_allocator_t&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Finalizes and frees barrier.</p>
<p>Do not call if barrier is in use, e.g. if threads are waiting on it.</p>
<p>The platfrom backend functions to destroy the internals of the barrier might not go through the allocator provided but might call free directly.</p>
<p>allocator_context and dealloc_func must be capable of freeing the memory allocated by the create function, otherwise behavior is undefined, resources might be leaked, and barrier might end in an invalid and unrescueable state.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>AMP_SUCCESS on successful finalization and freeing of barrier. Error codes might be returned to signal errors, too. These are programming errors and mustn't occur in release code. When <em>amp</em> is compiled without NDEBUG set it might assert that these programming errors don't happen. AMP_ERROR is returned if barrier or allocator are NULL or if threads are waiting on the barrier. </dd></dl>

</div>
</div>
<a class="anchor" id="ab8fdfd8c2b41e4d557fdcdc51f68b4a9"></a><!-- doxytag: member="amp_barrier.h::amp_barrier_wait" ref="ab8fdfd8c2b41e4d557fdcdc51f68b4a9" args="(amp_barrier_t barrier)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int amp_barrier_wait </td>
          <td>(</td>
          <td class="paramtype">amp_barrier_t&nbsp;</td>
          <td class="paramname"> <em>barrier</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Blocks a thread to wait on the barrier till as many threads are waiting as was specified by init_count when creating the barrier.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>AMP_SUCCESS if enough threads wait on the barrier so all are woken up and pass it. AMP_BARRIER_SERIAL_THREAD is returned to exactly one thread. This thread could then do some preparation work while all others wait on the next barrier that guards the start of the next parallel computations done by all threads. Error codes might be returned to signal errors, too. These are programming errors and mustn't occur in release code. When <em>amp</em> is compiled without NDEBUG set it might assert that these programming errors don't happen. AMP_ERROR might be returned if barrier is not valid. </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Oct 12 2011 15:00:35 for FlightlessManacotti by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
