<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>FlightlessManacotti: runtime/src/thirdparty/amp/src/c/amp/amp_semaphore.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>runtime/src/thirdparty/amp/src/c/amp/amp_semaphore.h File Reference</h1>  </div>
</div>
<div class="contents">
<code>#include &lt;stddef.h&gt;</code><br/>
<code>#include &lt;<a class="el" href="amp__stdint_8h_source.html">amp/amp_stdint.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="amp__memory_8h_source.html">amp/amp_memory.h</a>&gt;</code><br/>

<p><a href="amp__semaphore_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="amp__semaphore_8h.html#a9cc572800c2b299f022147dc67fc06a8">AMP_SEMAPHORE_UNINITIALIZED</a>&nbsp;&nbsp;&nbsp;NULL</td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef intptr_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="amp__semaphore_8h.html#acc60cdeefc161cbcc720f1cb2f399931">amp_semaphore_counter_t</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="amp__semaphore_8h.html#aee3b4cd5108e72705d372b28323f7a43">amp_semaphore_create</a> (amp_semaphore_t *semaphore, amp_allocator_t allocator, <a class="el" href="amp__semaphore_8h.html#acc60cdeefc161cbcc720f1cb2f399931">amp_semaphore_counter_t</a> init_count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="amp__semaphore_8h.html#a4c837c07200c8820e3773f134d6b5fa6">amp_semaphore_destroy</a> (amp_semaphore_t *semaphore, amp_allocator_t allocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="amp__semaphore_8h.html#a51c8b55de899d917a22b1e4eda8786e4">amp_semaphore_wait</a> (amp_semaphore_t semaphore)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="amp__semaphore_8h.html#a08451c6b9a10310237bb1a78e2fd052b">amp_semaphore_signal</a> (amp_semaphore_t semaphore)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="amp__semaphore_8h.html#ae1b2c106eef4ef6a487c3ffb6c7b2875">amp_semaphore_trywait_PROPOSED</a> (amp_semaphore_t semaphore)</td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a9cc572800c2b299f022147dc67fc06a8"></a><!-- doxytag: member="amp_semaphore.h::AMP_SEMAPHORE_UNINITIALIZED" ref="a9cc572800c2b299f022147dc67fc06a8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AMP_SEMAPHORE_UNINITIALIZED&nbsp;&nbsp;&nbsp;NULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Shallow wrapper around a semaphore type of the platform. An amp_semaphore can not be shared between two processes, each process only has access to its own semaphores.</p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>Don't pass pointers to an invalid semaphore to any of the functions. Don't pass non-initialized (or after initialization destroyed) semaphores to any function other than to amp_raw_semaphore_init. Don't pass initialized semaphores to amp_raw_semaphore_init.</dd></dl>
<p>TODO:</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000025">Todo:</a></b></dt><dd><p class="startdd">Add amp_semaphore_trywait. TODO: </p>
<p class="enddd">Decide if to add amp_semaphore_max_count. </p>
</dd></dl>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="acc60cdeefc161cbcc720f1cb2f399931"></a><!-- doxytag: member="amp_semaphore.h::amp_semaphore_counter_t" ref="acc60cdeefc161cbcc720f1cb2f399931" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef intptr_t <a class="el" href="amp__semaphore_8h.html#acc60cdeefc161cbcc720f1cb2f399931">amp_semaphore_counter_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Seamphore counter type. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aee3b4cd5108e72705d372b28323f7a43"></a><!-- doxytag: member="amp_semaphore.h::amp_semaphore_create" ref="aee3b4cd5108e72705d372b28323f7a43" args="(amp_semaphore_t *semaphore, amp_allocator_t allocator, amp_semaphore_counter_t init_count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int amp_semaphore_create </td>
          <td>(</td>
          <td class="paramtype">amp_semaphore_t *&nbsp;</td>
          <td class="paramname"> <em>semaphore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">amp_allocator_t&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="amp__semaphore_8h.html#acc60cdeefc161cbcc720f1cb2f399931">amp_semaphore_counter_t</a>&nbsp;</td>
          <td class="paramname"> <em>init_count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a semaphore by allocating memory and initializing it with a counter value of init_count and assigns the result to where semaphore points.</p>
<p>Internal calls to the platform semaphore API can result in memory allocations that bypass the argument supplied allocator.</p>
<p>Platforms limit the number of semaphores that can be created and active concurrently - creating too many semaphore won't succeed and an error code will be returned.</p>
<p>Platforms and amp limit the maximum value a semaphore count can carry. If an overflow (or underflow) would happen the function called won't succeed and an error code is returned.</p>
<p>If the initialization fails the allocator is called to free the already allocated memory which must not result in an error or otherwise behavior is undefined.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>AMP_SUCCESS on successful initialization, otherwise: AMP_NOMEM if memory is insufficient. AMP_ERROR if other system resources are insufficient, e.g. too many semaphores have been created. AMP_UNSUPPORTED if the backend in use doesn't support semaphores. Use another backend while building the library. Other error codes might be returned to signal errors while initializing, too. These are programming errors and mustn't occur in release code. When <em>amp</em> is compiled without NDEBUG set it might assert that these programming errors don't happen. AMP_ERROR if the semaphore is invalid, the init_count is negative or greater than AMP_RAW_SEMAPHORE_COUNT_MAX. AMP_ERROR if the process lacks privileges to initialize the semaphore or if the semaphore is in use.</dd></dl>
<dl class="attention"><dt><b>Attention:</b></dt><dd>semaphore mustn't be NULL.</dd>
<dd>
Don't pass an initialized (and not finalized after initialization) semaphore to amp_semaphore_create.</dd>
<dd>
init_count mustn't be negative and mustn't be greater than AMP_RAW_SEMAPHORE_COUNT_MAX. </dd></dl>

</div>
</div>
<a class="anchor" id="a4c837c07200c8820e3773f134d6b5fa6"></a><!-- doxytag: member="amp_semaphore.h::amp_semaphore_destroy" ref="a4c837c07200c8820e3773f134d6b5fa6" args="(amp_semaphore_t *semaphore, amp_allocator_t allocator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int amp_semaphore_destroy </td>
          <td>(</td>
          <td class="paramtype">amp_semaphore_t *&nbsp;</td>
          <td class="paramname"> <em>semaphore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">amp_allocator_t&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Finalizes and destroys semaphore and frees the resources it used.</p>
<p>The platform semaphore API's finalization routines might bypass the user provided allocator.</p>
<p>On destruction the semaphore counter should be equal to the init count set on creation, therefore balance signaling and waiting.</p>
<p>allocator_context and dealloc_func must be capable of freeing the memory allocated via the create function otherwise behavior is undefined and resources might be leaked.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>AMP_SUCCESS on successful finalization and destruction. AMP_UNSUPPORTED if the backend doesn't support semaphores. Error codes might be returned to signal errors while finalization, too. These are programming errors and mustn't occur in release code. When <em>amp</em> is compiled without NDEBUG set it might assert that these programming errors don't happen. AMP_BUSY if threads block on the semaphore. AMP_ERROR if the semaphore isn't valid, e.g. not initialized.</dd></dl>
<dl class="attention"><dt><b>Attention:</b></dt><dd>semaphore mustn't be NULL.</dd>
<dd>
Don't pass an uninitialized semaphore into amp_semaphore_destroy.</dd>
<dd>
Don't call on a blocked semaphore, otherwise behavior is undefined. </dd></dl>

</div>
</div>
<a class="anchor" id="a08451c6b9a10310237bb1a78e2fd052b"></a><!-- doxytag: member="amp_semaphore.h::amp_semaphore_signal" ref="a08451c6b9a10310237bb1a78e2fd052b" args="(amp_semaphore_t semaphore)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int amp_semaphore_signal </td>
          <td>(</td>
          <td class="paramtype">amp_semaphore_t&nbsp;</td>
          <td class="paramname"> <em>semaphore</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Increments the semaphore counter by one and if threads are blocked on the semaphore one of them is woken up and gets the chance to decrease the counter and pass the semaphore to execute on.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>AMP_SUCCESS after succesful signaling the semaphore. AMP_UNSUPPORTED if the backend doesn't support semaphores. AMP_ERROR if the semaphore counter value exceeds AMP_RAW_SEMAPHORE_COUNT_MAX . Error codes might be returned to signal errors while signaling, too. These are programming errors and mustn't occur in release code. When <em>amp</em> is compiled without NDEBUG set it might assert that these programming errors don't happen. AMP_ERROR if the semaphore isn't valid, e.g. not initialized, or if a deadlock condition is detected, or if the process lacks privileges to signal the semaphore.</dd></dl>
<dl class="attention"><dt><b>Attention:</b></dt><dd>semaphore mustn't be NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="ae1b2c106eef4ef6a487c3ffb6c7b2875"></a><!-- doxytag: member="amp_semaphore.h::amp_semaphore_trywait_PROPOSED" ref="ae1b2c106eef4ef6a487c3ffb6c7b2875" args="(amp_semaphore_t semaphore)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int amp_semaphore_trywait_PROPOSED </td>
          <td>(</td>
          <td class="paramtype">amp_semaphore_t&nbsp;</td>
          <td class="paramname"> <em>semaphore</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If the semaphore counter is not zero decrements the counter and returns. If the counter is zero, this function will not alter the semaphore counter and will return immediately.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is a proposed function, and the implementation has not yet been approved by the project author for inclusion in the library.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>AMP_SUCCESS if semphore was locked successfuly. AMP_BUSY if semaphore counter was 0 when attempted. AMP_ERROR if the semaphore was interrupted by a signal when using a backend that supports signal interruption. AMP_UNSUPPORTED if the backend doesn't support semaphores. Error codes might be returned to signal errors while waiting, too. These are programming errors and mustn't occur in release code. When <em>amp</em> is compiled without NDEBUG set it might assert that these programming errors don't happen. AMP_ERROR if a deadlock condition was detected, or if the semaphore isn't valid, e.g. not initialized, or if the process lacks privileges to wait on the semaphore.</dd></dl>
<dl class="attention"><dt><b>Attention:</b></dt><dd>sem mustn't be NULL.</dd>
<dd>
Based on the backend amp_raw_semaphores might or might not react to / are or are not usable with signals. Set the threads signal mask to not let any signals through.</dd></dl>
<p>TODO:</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000027">Todo:</a></b></dt><dd>Decide if OS signals should be able to interrupt the waiting. </dd></dl>

</div>
</div>
<a class="anchor" id="a51c8b55de899d917a22b1e4eda8786e4"></a><!-- doxytag: member="amp_semaphore.h::amp_semaphore_wait" ref="a51c8b55de899d917a22b1e4eda8786e4" args="(amp_semaphore_t semaphore)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int amp_semaphore_wait </td>
          <td>(</td>
          <td class="paramtype">amp_semaphore_t&nbsp;</td>
          <td class="paramname"> <em>semaphore</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If the semaphore counter is not zero decrements the counter and returns. If the counter is zero the thread blocks until the semaphore counter becomes greater than zero again and its the threads turn to decrease and it and return to work on.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>AMP_SUCCESS after waited successful on the semaphore. AMP_ERROR if the semaphore was interrupted by a signal when using a backend that supports signal interruption. AMP_UNSUPPORTED if the backend doesn't support semaphores. Error codes might be returned to signal errors while waiting, too. These are programming errors and mustn't occur in release code. When <em>amp</em> is compiled without NDEBUG set it might assert that these programming errors don't happen. AMP_ERROR if a deadlock condition was detected, or if the semaphore isn't valid, e.g. not initialized, or if the process lacks privileges to wait on the semaphore.</dd></dl>
<dl class="attention"><dt><b>Attention:</b></dt><dd>sem mustn't be NULL.</dd>
<dd>
Based on the backend amp_raw_semaphores might or might not react to / are or are not usable with signals. Set the threads signal mask to not let any signals through.</dd></dl>
<p>TODO:</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000026">Todo:</a></b></dt><dd>Decide if OS signals should be able to interrupt the waiting. </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Oct 12 2011 15:00:35 for FlightlessManacotti by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
