<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>FlightlessManacotti: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Todo List </h1>  </div>
</div>
<div class="contents">
<p><a class="anchor" id="_todo000001"></a> </p>
<dl>
<dt>File <a class="el" href="amp_8h.html">amp.h</a>  </dt>
<dd><p class="startdd">Instead of using assert use an own assertion-macro that allows abortion only in debug mode or, if a compile time preprocessor symbol is set, also aborting in non-debug mode, to clearly point to problem areas in the code instead of hiding them behind undefined behavior.</p>
<p>Add a section to the readme files how to build <em>amp</em> on the different supported platforms. Mention the need for <em>UnitTest++</em> .</p>
<p>Implement setting or using _WIN32_WINNT to include Windows version specific functionality correctly.</p>
<p>Document all AMP_USE_ prefixed preprocessor symbols to differentiate specific platform backends (Windows Vista condition variables, Mac OS X 10.6 dispatch semaphores.</p>
<p class="enddd">Add error preprocessor commands to all platform-ifdefs to signal where new platforms need to add code when adapting them. </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000006"></a> </p>
<dl>
<dt>File <a class="el" href="amp__barrier_8h.html">amp_barrier.h</a>  </dt>
<dd><p class="startdd">Decide if to add a function to trywait if a barrier would be left by waiting on it. Do this via a register/unregister trywait functionality so the barrier can internally count if the already waiting threads and the one who registerd for trywait would be enought to resolve and leave the barrier.</p>
<p class="enddd">The moment hardware supports it add a barrier type that is only valid for a group of cores - think OpenCL workgroup barriers. </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000008"></a> </p>
<dl>
<dt>File <a class="el" href="amp__internal__platform__win__system__logical__processor__information_8h.html">amp_internal_platform_win_system_logical_processor_information.h</a>  </dt>
<dd>Find out if pre Windows Vista reports hardware threads or cores? </dd>
</dl>
<p><a class="anchor" id="_todo000009"></a> </p>
<dl>
<dt>File <a class="el" href="amp__internal__thread_8h.html">amp_internal_thread.h</a>  </dt>
<dd><p class="startdd">When introducing export macros and statements make sure to hide internals.</p>
<p>When adding the ability to detach a thread add a check to the native thread adapter function to check for detachment and to store and free the memory resources used by the thread. The detach function should therefore take an allocator context and dealloc function argument.</p>
<p class="enddd">amp_internal_thread_id querying is a terrible hack on Pthreads right now. Fix it the moment atomics are supported and move the whole thread id querying to the public thread header. </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000012"></a> </p>
<dl>
<dt>Global <a class="el" href="amp__internal__thread_8h.html#ab4b5855f5202994f274dae5b09f9c63f">amp_internal_thread_state</a>  </dt>
<dd>Add possibility to detach an amp thread. Look at all occurences of joinable and joined states to handle the detached state, too. </dd>
</dl>
<p><a class="anchor" id="_todo000013"></a> </p>
<dl>
<dt>File <a class="el" href="amp__memory_8h.html">amp_memory.h</a>  </dt>
<dd>Add a test, especially to check the amp_calloc_func_t contract. </dd>
</dl>
<p><a class="anchor" id="_todo000014"></a> </p>
<dl>
<dt>File <a class="el" href="amp__mutex_8h.html">amp_mutex.h</a>  </dt>
<dd><p class="startdd">Rework the documentation to be more concise. </p>
<p class="enddd">At least on Windows store the locking threads id to detect if wrong thread tries to unlock in debug mode. </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000016"></a> </p>
<dl>
<dt>File <a class="el" href="amp__platform_8h.html">amp_platform.h</a>  </dt>
<dd><p class="startdd">Add detection for the number of packages (CPU dies), cores per package, hw-threads per core. Take non-homoheneous platforms into account. Also detect memory and cache sizes and cache / local storage grouping of hw-threads and cores and detect if the platform is an UMA or NUMA architecture. Add ways to detect if specific infos can be determined or not on the platform in use. TODO: </p>
<p>Decide if to implement the following functions: size_t amp_platform_get_package_type_count(void); size_t amp_platform_get_package_count_for_type(size_t package_type_id); size_t amp_platform_get_core_type_count(size_t package_type_id); size_t amp_platform_get_installed_core_count_for_type(size_t package_type_id, size_t core_type_for_package_type_id); size_t amp_platform_get_installed_hwthread_count(size_t package_type_id, size_t core_type_for_package_type_id); TODO: </p>
<p>Add source file using GetLogicalProcessorInformationEx to query the platform on Windows Vista or later Windows versions. TODO: </p>
<p class="enddd">Check back with Windows platform query documentation to only create a query buffer on platform creation instead of using the stored allocator for each query.</p>
</dd>
</dl>
<p><a class="anchor" id="_todo000018"></a> </p>
<dl>
<dt>Class <a class="el" href="structamp__raw__platform__s.html">amp_platform_t</a>  </dt>
<dd>If WinVist and Win7 platform query functions always use the same buffer size for queries then change the implementation to use a buffer instead of alloc and dealloc all the time. </dd>
</dl>
<p><a class="anchor" id="_todo000017"></a> </p>
<dl>
<dt>File <a class="el" href="amp__raw__mutex_8h.html">amp_raw_mutex.h</a>  </dt>
<dd>Add Apple OS X 10.6 libdispatch backends for amp_raw_ mutex. </dd>
</dl>
<p><a class="anchor" id="_todo000019"></a> </p>
<dl>
<dt>File <a class="el" href="amp__raw__semaphore_8h.html">amp_raw_semaphore.h</a>  </dt>
<dd><p class="startdd">Add a state variable to <a class="el" href="structamp__raw__semaphore__s.html">amp_raw_semaphore_s</a> to help detecting use of an uninitialized instance.</p>
<p>Document return codes for all supported platforms.</p>
<p>When adding a trywait function look if POSIX specifies EBUSY or EAGAIN as a return value to indicate that the thread would block.</p>
<p class="enddd">Add a way to ensure that the calls to signal and wait are balanced before a semaphore is finalized or detroyed. </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000027"></a> </p>
<dl>
<dt>Global <a class="el" href="amp__semaphore_8h.html#ae1b2c106eef4ef6a487c3ffb6c7b2875">amp_semaphore_trywait_PROPOSED</a> (amp_semaphore_t semaphore) </dt>
<dd>Decide if OS signals should be able to interrupt the waiting. </dd>
</dl>
<p><a class="anchor" id="_todo000025"></a> </p>
<dl>
<dt>Global <a class="el" href="amp__semaphore_8h.html#a9cc572800c2b299f022147dc67fc06a8">AMP_SEMAPHORE_UNINITIALIZED</a>  </dt>
<dd><p class="startdd">Add amp_semaphore_trywait. TODO: </p>
<p class="enddd">Decide if to add amp_semaphore_max_count. </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000026"></a> </p>
<dl>
<dt>Global <a class="el" href="amp__semaphore_8h.html#a51c8b55de899d917a22b1e4eda8786e4">amp_semaphore_wait</a> (amp_semaphore_t semaphore) </dt>
<dd>Decide if OS signals should be able to interrupt the waiting. </dd>
</dl>
<p><a class="anchor" id="_todo000030"></a> </p>
<dl>
<dt>Global <a class="el" href="amp__thread__array_8h.html#aacace5962efe2a0f87194c0c88779456">amp_thread_array_create</a> (amp_thread_array_t *thread_array, amp_allocator_t allocator, size_t thread_count) </dt>
<dd>Decide if to allow <code>0</code> as a thread count. </dd>
</dl>
<p><a class="anchor" id="_todo000029"></a> </p>
<dl>
<dt>Global <a class="el" href="amp__thread_8h.html#a223b27680c75168bc1d06729a7b6f19d">amp_thread_func_t</a> )(void *context) </dt>
<dd>Switch to returning an int to align with the next C 1x standard. </dd>
</dl>
<p><a class="anchor" id="_todo000024"></a> </p>
<dl>
<dt>Global <a class="el" href="structamp__raw__thread__s.html#a89f234133d3efe315836311cbf21c64b">amp_thread_t::state</a>  </dt>
<dd>The moment the amp atomic operations are ready make it an atomically changed flag that is queryable. Currently it can only be used by the thread that creates and launches (both by the same thread) the amp thread in a reliable way. </dd>
</dl>
<p><a class="anchor" id="_todo000028"></a> </p>
<dl>
<dt>Global <a class="el" href="amp__thread_8h.html#accce36b5e7893257c331d751db97332d">AMP_THREAD_UNINITIALIZED</a>  </dt>
<dd><p class="startdd">Manage threads when using cocoa (create at least one NSTask and create an autoreleasepool inside the threads. TODO: </p>
<p>Add docs to say how many threads can run at max and if joined thread slots are recycled or are blocked for the runtime of the app. Decide if the id is really necessary. TODO: </p>
<p class="enddd">Decide, implement, and document if amp threads surpress signals from reaching them. </p>
</dd>
</dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Oct 12 2011 15:00:36 for FlightlessManacotti by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
