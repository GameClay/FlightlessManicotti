<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>FlightlessManacotti: runtime/src/thirdparty/amp/src/c/amp/amp_thread.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>runtime/src/thirdparty/amp/src/c/amp/amp_thread.h File Reference</h1>  </div>
</div>
<div class="contents">
<code>#include &lt;stddef.h&gt;</code><br/>
<code>#include &lt;<a class="el" href="amp__stdint_8h_source.html">amp/amp_stdint.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="amp__memory_8h_source.html">amp/amp_memory.h</a>&gt;</code><br/>

<p><a href="amp__thread_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="amp__thread_8h.html#accce36b5e7893257c331d751db97332d">AMP_THREAD_UNINITIALIZED</a>&nbsp;&nbsp;&nbsp;NULL</td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="amp__thread_8h.html#a223b27680c75168bc1d06729a7b6f19d">amp_thread_func_t</a> )(void *context)</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="amp__thread_8h.html#a0dcbdd9e637daa4b92ecdf3e65743a70">amp_thread_create_and_launch</a> (amp_thread_t *thread, amp_allocator_t allocator, void *func_context, <a class="el" href="amp__thread_8h.html#a223b27680c75168bc1d06729a7b6f19d">amp_thread_func_t</a> func)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="amp__thread_8h.html#aa315cc39322d6eb0aaa6bfdc63b7d8b8">amp_thread_join_and_destroy</a> (amp_thread_t *thread, amp_allocator_t allocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="amp__thread_8h.html#adb941973c8159536a3ce760a4453b069">amp_thread_yield</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="amp__thread_8h.html#a12b37d9bf7141b62470877ecdbb8966e">amp_thread_raw_exit</a> (void)</td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="accce36b5e7893257c331d751db97332d"></a><!-- doxytag: member="amp_thread.h::AMP_THREAD_UNINITIALIZED" ref="accce36b5e7893257c331d751db97332d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AMP_THREAD_UNINITIALIZED&nbsp;&nbsp;&nbsp;NULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Shallow wrapper around the platforms threads. Threads launched must always be joined to prevent resource leaks. Currently threads can't be detached.</p>
<p>Thanks to Jedd Orion Haberstro for feedback to the documentation of amp_thread_yield which resulted in a clearer explanation of the function.</p>
<p>TODO:</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000028">Todo:</a></b></dt><dd><p class="startdd">Manage threads when using cocoa (create at least one NSTask and create an autoreleasepool inside the threads. TODO: </p>
<p>Add docs to say how many threads can run at max and if joined thread slots are recycled or are blocked for the runtime of the app. Decide if the id is really necessary. TODO: </p>
<p class="enddd">Decide, implement, and document if amp threads surpress signals from reaching them. </p>
</dd></dl>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a223b27680c75168bc1d06729a7b6f19d"></a><!-- doxytag: member="amp_thread.h::amp_thread_func_t" ref="a223b27680c75168bc1d06729a7b6f19d" args=")(void *context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="amp__thread_8h.html#a223b27680c75168bc1d06729a7b6f19d">amp_thread_func_t</a>)(void *context)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Type of the user function to run on the thread. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>user data passed into the function.</td></tr>
  </table>
  </dd>
</dl>
<p>TODO:</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000029">Todo:</a></b></dt><dd>Switch to returning an int to align with the next C 1x standard. </dd></dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a0dcbdd9e637daa4b92ecdf3e65743a70"></a><!-- doxytag: member="amp_thread.h::amp_thread_create_and_launch" ref="a0dcbdd9e637daa4b92ecdf3e65743a70" args="(amp_thread_t *thread, amp_allocator_t allocator, void *func_context, amp_thread_func_t func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int amp_thread_create_and_launch </td>
          <td>(</td>
          <td class="paramtype">amp_thread_t *&nbsp;</td>
          <td class="paramname"> <em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">amp_allocator_t&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>func_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="amp__thread_8h.html#a223b27680c75168bc1d06729a7b6f19d">amp_thread_func_t</a>&nbsp;</td>
          <td class="paramname"> <em>func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates and launches a thread.</p>
<p>To wait on the thread and also free the memory it uses call amp_thread_join_and_destroy.</p>
<p>Mental thread model: a thread is like a spaceship. After launch it needs to explicitly land (join) - otherwise it just crashes with undefined behavior for the whole surrounding of the crash-site.</p>
<p>Might call the systems malloc internally to create platform internal thread representation.</p>
<p>If fed with already launched native thread behavior is undefined.</p>
<p>If the initialization fails the allocator is called to free the already allocated memory which must not result in an error or otherwise behavior is undefined.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>AMP_SUCCESS on successful thread launch. AMP_ERROR if the system is lacking resources for thread creation. AMP_NOMEM if the system is lacking memory to create the thread. Other error codes might be returned to signal errors while launching, too. These are programming errors and mustn't occur in release code. When <em>amp</em> is compiled without NDEBUG set it might assert that these programming errors don't happen. AMP_ERROR if the thread or the thread function is invalid.</dd></dl>
<dl class="attention"><dt><b>Attention:</b></dt><dd>A platform might restrict the number of threads which can be created system wide or per process.</dd>
<dd>
Passing NULL for <em>thread</em> or <em>func</em> results in undefined behavior.</dd>
<dd>
Don't pass an already existing thread in or you won't be able to join with it which results in a resource leak and undefined behavior. </dd></dl>

</div>
</div>
<a class="anchor" id="aa315cc39322d6eb0aaa6bfdc63b7d8b8"></a><!-- doxytag: member="amp_thread.h::amp_thread_join_and_destroy" ref="aa315cc39322d6eb0aaa6bfdc63b7d8b8" args="(amp_thread_t *thread, amp_allocator_t allocator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int amp_thread_join_and_destroy </td>
          <td>(</td>
          <td class="paramtype">amp_thread_t *&nbsp;</td>
          <td class="paramname"> <em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">amp_allocator_t&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Waits until the thread ends and frees its resources.</p>
<p>If thread hasn't been launched behavior is undefined.</p>
<p>If joining with a thread was not successful the memory of thread will not be freed.</p>
<p>allocator must be capable of freeing the memory allocated by the create function otherwise behavior is undefined and resources might be leaked.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>AMP_SUCCESS after succesfully joining with the thread. Other error codes might be returned to signal errors while joining, too. These are programming errors and mustn't occur in release code. When <em>amp</em> is compiled without NDEBUG set it might assert that these programming errors don't happen. AMP_ERROR might be reported if a deadlock condition was detected, or if the calling thread tries to join with itself, or if the argument doesn't refer to a joinable thread, or if if no system thread is associated with the argument.</dd></dl>
<dl class="attention"><dt><b>Attention:</b></dt><dd>Only pass a thread as an argument if its launching was successful, otherwise behavior is undefined.</dd>
<dd>
Don't try to join a thread with itself, otherwise behavior is undefined. </dd></dl>

</div>
</div>
<a class="anchor" id="a12b37d9bf7141b62470877ecdbb8966e"></a><!-- doxytag: member="amp_thread.h::amp_thread_raw_exit" ref="a12b37d9bf7141b62470877ecdbb8966e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void amp_thread_raw_exit </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Terminates the calling thread</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>This function can not return a value.</dd></dl>
<dl class="attention"><dt><b>Attention:</b></dt><dd>This function has different behavior depending on the operating system. Some will call destructors, and some will not. </dd></dl>

</div>
</div>
<a class="anchor" id="adb941973c8159536a3ce760a4453b069"></a><!-- doxytag: member="amp_thread.h::amp_thread_yield" ref="adb941973c8159536a3ce760a4453b069" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int amp_thread_yield </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Tells the operating system that it might be benificial to context switch to another thread.</p>
<p>Based on the platform/backend an immediate context switch can occur - or not. The POSIX/Pthreads backend and the Windows threads backend will context switch immediately, other backends might behave differently.</p>
<p>Suggestion from David R. Butenhof's book "Programming with POSIX threads", p. 316 : call before locking a mutex to minimize the chance of a context switch while a mutex is locked.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>AMP_SUCCESS on success, otherwise AMP_UNSUPPORTED is returned if not supported.</dd></dl>
<p>Thanks to Jedd Orion Haberstro for a clarified documentation if amp_thread_yield results in an immediate context switch or if it is merrely a hint (as documented before). Answer: it depends on the platform in use. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Oct 12 2011 15:00:35 for FlightlessManacotti by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
