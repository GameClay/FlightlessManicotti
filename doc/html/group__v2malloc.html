<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>FlightlessManacotti: The v2 malloc API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a>  </div>
  <div class="headertitle">
<h1>The v2 malloc API</h1>  </div>
</div>
<div class="contents">
<hr/><a name="_details"></a><h2> </h2>
<p>For the v1.10 release which was generously sponsored by <a href="http://www.ara.com/" target="_blank">Applied Research Associates (USA)</a>, a new general purpose allocator API was designed which is intended to remedy many of the long standing problems and inefficiencies introduced by the ISO C allocator API. Internally nedalloc's implementations of <a class="el" href="nedmalloc_8h.html#a4742f37b710c97c0accd6723849dc1f9" title="Equivalent to nedpmalloc2((nedpool *) 0, size, 0, 0).">nedmalloc()</a>, <a class="el" href="nedmalloc_8h.html#a4cb848554ff52576571bcf2895cc92d3" title="Equivalent to nedpmalloc2((nedpool *) 0, no*size, 0, M2_ZERO_MEMORY).">nedcalloc()</a>, <a class="el" href="nedmalloc_8h.html#aee7065e0dee34235de5828be4e3ed9b3" title="Equivalent to nedpmalloc2((nedpool *) 0, size, alignment, 0).">nedmemalign()</a> and <a class="el" href="nedmalloc_8h.html#a0bcd2c72da9cc692f2ef6ce51a31abfb" title="Equivalent to nedprealloc2((nedpool *) 0, size, mem, size, 0, M2_RESERVE_MULT(8)).">nedrealloc()</a> call into this API:</p>
<ul>
<li>
<code>void* malloc2(size_t bytes, size_t alignment, unsigned flags)</code> </li>
<li>
<code>void* realloc2(void* mem, size_t bytes, size_t alignment, unsigned flags)</code> </li>
<li>
<code>void free2(void* mem, unsigned flags)</code> </li>
</ul>
<p>If <a class="el" href="nedmalloc_8h.html" title="Defines the functionality provided by nedalloc.">nedmalloc.h</a> is being included by C++ code, the alignment and flags parameters default to zero which makes the new API identical to the old API (roll on the introduction of default parameters to C!). The ability for realloc2() to take an alignment is <em>particularly</em> useful for extending aligned vector arrays such as SSE/AVX vector arrays. Hitherto SSE/AVX vector code had to jump through all sorts of unpleasant hoops to maintain alignment :(.</p>
<p>Note that using any of these flags other than M2_ZERO_MEMORY or any alignment other than zero inhibits the threadcache.</p>
<p>Currently MREMAP support is limited to Linux and Windows. Patches implementing support for other platforms are welcome.</p>
<p>On Linux the non portable mremap() kernel function is currently used, so in fact the M2_RESERVE_* options are currently ignored.</p>
<p>On Windows, there are two different MREMAP implementations which are chosen according to whether a 32 bit or a 64 bit build is being performed. The 32 bit implementation is based on Win32 file mappings where it reserves the address space within the Windows VM system, so you can safely specify silly reservation quantities like 2Gb per block and not exhaust local process address space. Note however that on x86 this costs 2Kb (1Kb if PAE is off) of kernel memory per Mb reserved, and as kernel memory has a hard limit of 447Mb on x86 you will find the total address space reservable in the system is limited. On x64, or if you define WIN32_DIRECT_USE_FILE_MAPPINGS=0 on x86, a much faster implementation of using VirtualAlloc(MEM_RESERVE) to directly reserve the address space is used.</p>
<p>When using M2_RESERVE_* with realloc2(), the setting only takes effect when the mmapped chunk has exceeded its reservation space and a new reservation space needs to be created. </p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__v2malloc.html#ga891e082adaf7e50c10b4b144b7a785b4">M2_ZERO_MEMORY</a>&nbsp;&nbsp;&nbsp;(1&lt;&lt;0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the contents of the allocated block (or any increase in the allocated block) to zero.  <a href="#ga891e082adaf7e50c10b4b144b7a785b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__v2malloc.html#gabe20b076ffd4cbd4287d8bad37e4d906">M2_PREVENT_MOVE</a>&nbsp;&nbsp;&nbsp;(1&lt;&lt;1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cause realloc2() to attempt to extend a block in place, but to never move it.  <a href="#gabe20b076ffd4cbd4287d8bad37e4d906"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__v2malloc.html#ga835b4bb3dad6827f12fe6e58fdbb92bd">M2_ALWAYS_MMAP</a>&nbsp;&nbsp;&nbsp;(1&lt;&lt;2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Always allocate as though mmap_threshold were being exceeded.  <a href="#ga835b4bb3dad6827f12fe6e58fdbb92bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__v2malloc.html#ga69ce04f23411096e7834e2a3e83267f4">M2_RESERVE_MULT</a>(<a class="el" href="sieve_8lua.html#ac89c08da76492c3cc5ed775a73650a40">n</a>)&nbsp;&nbsp;&nbsp;(M2_RESERVE_ISMULTIPLIER|(((<a class="el" href="sieve_8lua.html#ac89c08da76492c3cc5ed775a73650a40">n</a>)&lt;&lt;8)&amp;M2_RESERVE_MASK))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reserve n times as much address space such that mmapped realloc2(size &lt;= n * original size) avoids memory copying and hence is much faster.  <a href="#ga69ce04f23411096e7834e2a3e83267f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__v2malloc.html#ga460acb88391514dd197d16ef7040a014">M2_RESERVE_SHIFT</a>(<a class="el" href="sieve_8lua.html#ac89c08da76492c3cc5ed775a73650a40">n</a>)&nbsp;&nbsp;&nbsp;(((<a class="el" href="sieve_8lua.html#ac89c08da76492c3cc5ed775a73650a40">n</a>)&lt;&lt;8)&amp;M2_RESERVE_MASK)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reserve (1&lt;&lt;n) bytes of address space such that mmapped realloc2(size &lt;= (1&lt;&lt;n)) avoids memory copying and hence is much faster.  <a href="#ga460acb88391514dd197d16ef7040a014"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__v2malloc.html#ga989cc8ad527f71fba6af8637f4c96537">NM_SKIP_TOLERANCE_CHECKS</a>&nbsp;&nbsp;&nbsp;(1&lt;&lt;31)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Causes nedmalloc to not inspect the block being passed to see if it belongs to the system allocator. Can improve speed by up to 10%.  <a href="#ga989cc8ad527f71fba6af8637f4c96537"></a><br/></td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga835b4bb3dad6827f12fe6e58fdbb92bd"></a><!-- doxytag: member="nedmalloc.h::M2_ALWAYS_MMAP" ref="ga835b4bb3dad6827f12fe6e58fdbb92bd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define M2_ALWAYS_MMAP&nbsp;&nbsp;&nbsp;(1&lt;&lt;2)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>In the case of realloc2(), note that setting this bit will not necessarily mmap a chunk which isn't already mmapped, but it will force a mmapped chunk if new memory needs allocating.</p>
<ul>
<li><b>Rationale:</b> If you know that an array you are allocating is going to be repeatedly extended up into the hundred of kilobytes range, then you can avoid the constant memory copying into larger blocks by specifying this flag at the beginning along with one of the M2_RESERVE_* flags below. This can <b>greatly</b> improve performance for large arrays. </li>
</ul>

</div>
</div>
<a class="anchor" id="gabe20b076ffd4cbd4287d8bad37e4d906"></a><!-- doxytag: member="nedmalloc.h::M2_PREVENT_MOVE" ref="gabe20b076ffd4cbd4287d8bad37e4d906" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define M2_PREVENT_MOVE&nbsp;&nbsp;&nbsp;(1&lt;&lt;1)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<ul>
<li><b>Rationale:</b> C++ makes almost no use of realloc(), even for contiguous arrays such as std::vector&lt;&gt; because most C++ objects cannot be relocated in memory without a copy or rvalue construction (though some clever STL implementations specialise for Plain Old Data (POD) types, and use realloc() then and only then). This flag allows C++ containers to speculatively try to extend in place, thus improving performance <em>especially</em> for large allocations which will use mmap(). </li>
</ul>

</div>
</div>
<a class="anchor" id="ga69ce04f23411096e7834e2a3e83267f4"></a><!-- doxytag: member="nedmalloc.h::M2_RESERVE_MULT" ref="ga69ce04f23411096e7834e2a3e83267f4" args="(n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define M2_RESERVE_MULT</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"><a class="el" href="sieve_8lua.html#ac89c08da76492c3cc5ed775a73650a40">n</a></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(M2_RESERVE_ISMULTIPLIER|(((<a class="el" href="sieve_8lua.html#ac89c08da76492c3cc5ed775a73650a40">n</a>)&lt;&lt;8)&amp;M2_RESERVE_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga460acb88391514dd197d16ef7040a014"></a><!-- doxytag: member="nedmalloc.h::M2_RESERVE_SHIFT" ref="ga460acb88391514dd197d16ef7040a014" args="(n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define M2_RESERVE_SHIFT</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"><a class="el" href="sieve_8lua.html#ac89c08da76492c3cc5ed775a73650a40">n</a></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(((<a class="el" href="sieve_8lua.html#ac89c08da76492c3cc5ed775a73650a40">n</a>)&lt;&lt;8)&amp;M2_RESERVE_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga891e082adaf7e50c10b4b144b7a785b4"></a><!-- doxytag: member="nedmalloc.h::M2_ZERO_MEMORY" ref="ga891e082adaf7e50c10b4b144b7a785b4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define M2_ZERO_MEMORY&nbsp;&nbsp;&nbsp;(1&lt;&lt;0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Note that this zeroes only the increase from what dlmalloc thinks the chunk's size is, so if you realloc2() a block which wasn't allocated using malloc2() using this flag then you may have garbage just before the newly extended space.</p>
<ul>
<li><b>Rationale:</b> Memory returned by the system is guaranteed to be zero on most platforms, and hence dlmalloc knows when it can skip zeroing memory. This improves performance. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga989cc8ad527f71fba6af8637f4c96537"></a><!-- doxytag: member="nedmalloc.h::NM_SKIP_TOLERANCE_CHECKS" ref="ga989cc8ad527f71fba6af8637f4c96537" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NM_SKIP_TOLERANCE_CHECKS&nbsp;&nbsp;&nbsp;(1&lt;&lt;31)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Oct 12 2011 15:00:36 for FlightlessManacotti by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
