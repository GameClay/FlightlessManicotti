<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>FlightlessManacotti: runtime/src/thirdparty/amp/src/c/amp/amp_condition_variable.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>runtime/src/thirdparty/amp/src/c/amp/amp_condition_variable.h File Reference</h1>  </div>
</div>
<div class="contents">
<code>#include &lt;stddef.h&gt;</code><br/>
<code>#include &lt;<a class="el" href="amp__mutex_8h_source.html">amp/amp_mutex.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="amp__memory_8h_source.html">amp/amp_memory.h</a>&gt;</code><br/>

<p><a href="amp__condition__variable_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="amp__condition__variable_8h.html#acf50e30678c719c7e0452984df35e96e">AMP_CONDITION_VARIABLE_UNINITIALIZED</a>&nbsp;&nbsp;&nbsp;NULL</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="amp__condition__variable_8h.html#a5ae89d2c2fdc22c26477e16c05b50764">amp_condition_variable_create</a> (amp_condition_variable_t *cond, amp_allocator_t allocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="amp__condition__variable_8h.html#aa047eed7d818afaf10ae0579d1bd7238">amp_condition_variable_destroy</a> (amp_condition_variable_t *cond, amp_allocator_t allocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="amp__condition__variable_8h.html#a0c3d1968f4971e621b4ace999e25edad">amp_condition_variable_broadcast</a> (amp_condition_variable_t cond)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="amp__condition__variable_8h.html#a2eac8f26f49d60aa57c0874e24f1c814">amp_condition_variable_signal</a> (amp_condition_variable_t cond)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="amp__condition__variable_8h.html#a348e43d9359c14febb065fbe2b8e7446">amp_condition_variable_wait</a> (amp_condition_variable_t cond, amp_mutex_t mutex)</td></tr>
</table>
<hr/><a name="_details"></a><h2> </h2>
<p>Simple implementation that behaves alike POSIX threads condition variables.</p>
<p>Never pass an invalid or NULL argument to the functions. Never pass a non-created condition variable to the functions other than the create function. Never pass a created function to the create function if it hasn't been destroyed before. Don't destroy a condition variable that is still in use by threads, e.g. while threads are waiting on it or might signal it later on. Creating a condition variable must only be done by a single thread and destroying a condition variable must only be done by a single thread, it isn't thread-safe. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="acf50e30678c719c7e0452984df35e96e"></a><!-- doxytag: member="amp_condition_variable.h::AMP_CONDITION_VARIABLE_UNINITIALIZED" ref="acf50e30678c719c7e0452984df35e96e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AMP_CONDITION_VARIABLE_UNINITIALIZED&nbsp;&nbsp;&nbsp;NULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a0c3d1968f4971e621b4ace999e25edad"></a><!-- doxytag: member="amp_condition_variable.h::amp_condition_variable_broadcast" ref="a0c3d1968f4971e621b4ace999e25edad" args="(amp_condition_variable_t cond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int amp_condition_variable_broadcast </td>
          <td>(</td>
          <td class="paramtype">amp_condition_variable_t&nbsp;</td>
          <td class="paramname"> <em>cond</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Wakes up all threads waiting on the condition variable. Only one thread will be able to get the lock of the associated mutex (see wait function below), all other will block while waiting on the lock. The "winner" thread will leave its call to amp_condition_variable_wait with the associated mutex locked by it. The thread calling broadcast can but needn't own the lock on the associated mutex.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>AMP_SUCCESS on successful broadcasting. Error codes might be returned to signal errors while broadcasting, too. These are programming errors and mustn't occur in release code. When <em>amp</em> is compiled without NDEBUG set it might assert that these programming errors don't happen. AMP_ERROR if the condition variable isn't valid. </dd></dl>

</div>
</div>
<a class="anchor" id="a5ae89d2c2fdc22c26477e16c05b50764"></a><!-- doxytag: member="amp_condition_variable.h::amp_condition_variable_create" ref="a5ae89d2c2fdc22c26477e16c05b50764" args="(amp_condition_variable_t *cond, amp_allocator_t allocator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int amp_condition_variable_create </td>
          <td>(</td>
          <td class="paramtype">amp_condition_variable_t *&nbsp;</td>
          <td class="paramname"> <em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">amp_allocator_t&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocates and initialized a condition variable.</p>
<p>Only call from one thread.</p>
<p>Behavior is undefined if calling it on an already created and not destroyed condition variable - resources will be leaked or worser.</p>
<p>If the initialization fails the allocator is called to free the already allocated memory which must not result in an error or otherwise behavior is undefined.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>AMP_SUCCESS if initialized successful, otherwise error codes are returned. AMP_ERROR if a system resource other than memory wasn't available. AMP_NOMEM if not enough memory is available. Error codes might be returned to signal errors while initializing, too. These are programming errors and mustn't occur in release code. When <em>amp</em> is compiled without NDEBUG set it might assert that these programming errors don't happen. AMP_BUSY if the condition variable is already initialized. AMP_ERROR if the condition variable is invalid or already initialized. </dd></dl>

</div>
</div>
<a class="anchor" id="aa047eed7d818afaf10ae0579d1bd7238"></a><!-- doxytag: member="amp_condition_variable.h::amp_condition_variable_destroy" ref="aa047eed7d818afaf10ae0579d1bd7238" args="(amp_condition_variable_t *cond, amp_allocator_t allocator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int amp_condition_variable_destroy </td>
          <td>(</td>
          <td class="paramtype">amp_condition_variable_t *&nbsp;</td>
          <td class="paramname"> <em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">amp_allocator_t&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Finalizes and frees the memory of a condition variable.</p>
<p>Only call from one thread when the condition variable isn't in use anymore.</p>
<p>allocator must be capable of freeing the memory allocated via the create function otherwise behavior is undefined and resources might be leaked.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>AMP_SUCCESS if the condition variable was successfully destroyed. Error codes might be returned to signal errors while finalizing, too. These are programming errors and mustn't occur in release code. When <em>amp</em> is compiled without NDEBUG set it might assert that these programming errors don't happen. AMP_ERROR the condition variable is invalid or allocator could not deallocate the condition variable. AMP_BUSY the condition variable is in use. </dd></dl>

</div>
</div>
<a class="anchor" id="a2eac8f26f49d60aa57c0874e24f1c814"></a><!-- doxytag: member="amp_condition_variable.h::amp_condition_variable_signal" ref="a2eac8f26f49d60aa57c0874e24f1c814" args="(amp_condition_variable_t cond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int amp_condition_variable_signal </td>
          <td>(</td>
          <td class="paramtype">amp_condition_variable_t&nbsp;</td>
          <td class="paramname"> <em>cond</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Wakes up an unspecified single waiting thread of the threads waiting on the condition variable. The woken up thread will leave the call to amp_condition_variable_wait with the associated mutex locked. The thread calling signal can but needn't own the lock on the associated mutex.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>AMP_SUCCESS on successful signaling. Error codes might be returned to signal errors while broadcasting, too. These are programming errors and mustn't occur in release code. When <em>amp</em> is compiled without NDEBUG set it might assert that these programming errors don't happen. AMP_ERROR if the condition variable isn't valid. </dd></dl>

</div>
</div>
<a class="anchor" id="a348e43d9359c14febb065fbe2b8e7446"></a><!-- doxytag: member="amp_condition_variable.h::amp_condition_variable_wait" ref="a348e43d9359c14febb065fbe2b8e7446" args="(amp_condition_variable_t cond, amp_mutex_t mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int amp_condition_variable_wait </td>
          <td>(</td>
          <td class="paramtype">amp_condition_variable_t&nbsp;</td>
          <td class="paramname"> <em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">amp_mutex_t&nbsp;</td>
          <td class="paramname"> <em>mutex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The thread calling amp_condition_variable_wait waits on the conditiona variable until awaken by a signal or broadcast. While waiting the mutex is unlocked. When awaking the associated mutex is re-locked. The thread should then re-check that the predicate or state condition it waited on via the condition variable is true or should wait on the condition variable again otherwise. The thread calling must own the lock on the mutex assocaited with the condition variable.</p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>Only call if the mutex is locked by the calling thread, otherwise behavior is undefined.</dd>
<dd>
A signal or broadcast can be missed when signal or broadcast are called without owning the mutex when the signal or broadcast is issued before the wait registered itself to wait on the condition variable. This doesn't hapen if signal or broadcast are called while owning the mutex.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>AMP_SUCCESS after the calling thread has been awoken by a signal or broadcast and has already locked the associated mutex. Error codes might be returned to signal errors while waiting, too. These are programming errors and mustn't occur in release code. When <em>amp</em> is compiled without NDEBUG set it might assert that these programming errors don't happen. AMP_ERROR is the condition variable or the mutex are invalid, or if different mutexes are used for concurrent waits on the same condition variable, or if the mutex isn't owned by the calling thread. </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Oct 12 2011 15:00:35 for FlightlessManacotti by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
