<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>FlightlessManacotti: runtime/src/thirdparty/amp/src/c/amp/amp_mutex.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>runtime/src/thirdparty/amp/src/c/amp/amp_mutex.h File Reference</h1>  </div>
</div>
<div class="contents">
<code>#include &lt;stddef.h&gt;</code><br/>
<code>#include &lt;<a class="el" href="amp__memory_8h_source.html">amp/amp_memory.h</a>&gt;</code><br/>

<p><a href="amp__mutex_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="amp__mutex_8h.html#afa845eccbfd19bf0444a2c048a060232">AMP_MUTEX_UNINITIALIZED</a>&nbsp;&nbsp;&nbsp;NULL</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="amp__mutex_8h.html#a35404904cdd0b237a050072e0a42bc1a">amp_mutex_create</a> (amp_mutex_t *mutex, amp_allocator_t allocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="amp__mutex_8h.html#a4da7412ddf266b87e92ba174dd5b8cf1">amp_mutex_destroy</a> (amp_mutex_t *mutex, amp_allocator_t allocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="amp__mutex_8h.html#a455955658af296519b4489847e9ddf88">amp_mutex_lock</a> (amp_mutex_t mutex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="amp__mutex_8h.html#af801a5957379c6a592479e7d3c6d4e47">amp_mutex_trylock</a> (amp_mutex_t mutex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="amp__mutex_8h.html#a358bd615b5a4c3015b8db7e7d2f8e325">amp_mutex_unlock</a> (amp_mutex_t mutex)</td></tr>
</table>
<hr/><a name="_details"></a><h2> </h2>
<p>Simple non-recursive mutex and a shallow wrapper around the platforms mutex or critical section primitive.</p>
<p>amp mutex guarantees that only one thread can lock it at a time. amp_mutex_t offers a way to synchronize access to a so called critical section wrapped in a mutex lock and unlock operation. As only one thread can be inside the critical section at a time, all shared resources accessed inside the critical section are protected from race conditions that could happen if another thread would execute the critical section concurrently.</p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>If someone accesses resources without using the single shared mutex associated with it to protect it, then race conditions can and will happen.</dd></dl>
<p>The thread locking the mutex attains its ownership and needs to unlock it, too. As long as a thread holds the mutex lock no other thread can lock it and will block and wait on the mutex to be unlocked. The moment the mutex is unlocked from its previous holder thread one thread that is blocked on the mutex will be woken up and it - or anothread that slips in calling lock - gets the lock. If the just woken up thread doesn't get the lock it will be blocked and waits on the lock again. Which thread actually attain the lock is non-deterministic and platform dependent. Don't rely on any order.</p>
<p>Before using a mutex it must be created via amp_mutex_create once. Don't forget to destroy the mutex to free its memory and OS internal resources by calling amp_mutex_destroy at the end of the mutex lifetime.</p>
<p>All functions working on mutexes return return codes. Check these return codes and don't enter a critical section or use a mutex if the return value isn't AMP_SUCCESS.</p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>If the thread already holding the mutex lock calls amp_mutex_lock recursively the behavior is undefined and might lead to a deadlock.</dd>
<dd>
If a thread that isn't holding a mutex lock tries to unlock the mutex behavior is undefined.</dd>
<dd>
If a invalid mutex is passed to any function behavior is undefined. More specifically, never pass an uninitialized (or after initialization finalized) mutex to any function other than amp_mutex_create. Never pass an initialized mutex to amp_mutex_create.</dd></dl>
<p>TODO:</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000014">Todo:</a></b></dt><dd>Rework the documentation to be more concise. </dd></dl>
<p>TODO:</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000015">Todo:</a></b></dt><dd>At least on Windows store the locking threads id to detect if wrong thread tries to unlock in debug mode. </dd></dl>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="afa845eccbfd19bf0444a2c048a060232"></a><!-- doxytag: member="amp_mutex.h::AMP_MUTEX_UNINITIALIZED" ref="afa845eccbfd19bf0444a2c048a060232" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AMP_MUTEX_UNINITIALIZED&nbsp;&nbsp;&nbsp;NULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a35404904cdd0b237a050072e0a42bc1a"></a><!-- doxytag: member="amp_mutex.h::amp_mutex_create" ref="a35404904cdd0b237a050072e0a42bc1a" args="(amp_mutex_t *mutex, amp_allocator_t allocator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int amp_mutex_create </td>
          <td>(</td>
          <td class="paramtype">amp_mutex_t *&nbsp;</td>
          <td class="paramname"> <em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">amp_allocator_t&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocates and initialize an amp_mutex_t before using it.</p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>The platform-specific init function called might use malloc or other resource management functions internally.</dd>
<dd>
Don't pass an already created mutex to amp_mutex_create as it could result in undefined behavior and resource leaks.</dd></dl>
<p>If the initialization fails the allocator is called to free the already allocated memory which must not result in an error or otherwise behavior is undefined.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>AMP_SUCCESS is returned on successful initialization of mutex. AMP_ERROR is returned if the system temporarily has insufficent resources. AMP_NOMEM is returned if memory is insufficient. Other error codes might be returned to signal errors while initializing, too. These are programming errors and mustn't occur in release code. When <em>amp</em> is compiled without NDEBUG set it might assert that these programming errors don't happen. AMP_ERROR might be returned when trying to create a mutex while the argument mutex points to an already exiting one. </dd></dl>

</div>
</div>
<a class="anchor" id="a4da7412ddf266b87e92ba174dd5b8cf1"></a><!-- doxytag: member="amp_mutex.h::amp_mutex_destroy" ref="a4da7412ddf266b87e92ba174dd5b8cf1" args="(amp_mutex_t *mutex, amp_allocator_t allocator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int amp_mutex_destroy </td>
          <td>(</td>
          <td class="paramtype">amp_mutex_t *&nbsp;</td>
          <td class="paramname"> <em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">amp_allocator_t&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Finalizes the mutex and frees its memory and platform resources.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>AMP_SUCCESS on successful destruction of the mutex. Error codes might be returned to signal errors while finalizing, too. These are programming errors and mustn't occur in release code. When <em>amp</em> is compiled without NDEBUG set it might assert that these programming errors don't happen. AMP_ERROR if the mutex attribute isn't valid, e.g. not initialized. AMP_BUSY if the mutex is locked by a thread.</dd></dl>
<p>allocator must be capable of freeing the memory allocated via the create function otherwise behavior is undefined and resources might be leaked.</p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>Only call for successfully initialized mutexes, otherwise behavior is undefined.</dd>
<dd>
Only call for mutexes which aren't locked by any thread and for which no threads are blocked waiting on the lock, otherwise behavior is undefined.</dd>
<dd>
The platform-specific destruction function called might use free or other resource management functions internally. </dd></dl>

</div>
</div>
<a class="anchor" id="a455955658af296519b4489847e9ddf88"></a><!-- doxytag: member="amp_mutex.h::amp_mutex_lock" ref="a455955658af296519b4489847e9ddf88" args="(amp_mutex_t mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int amp_mutex_lock </td>
          <td>(</td>
          <td class="paramtype">amp_mutex_t&nbsp;</td>
          <td class="paramname"> <em>mutex</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Locks the mutex or, if another thread holds the lock, blocks waiting until it gathers the mutex lock.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>AMP_SUCCESS is returned if locking is successful. Error codes might be returned to signal errors while locking, too. These are programming errors and mustn't occur in release code. When <em>amp</em> is compiled without NDEBUG set it might assert that these programming errors don't happen. AMP_ERROR if the thread already holding the lock attempts to lock again (recursively) or if the mutex is invalid, e.g. not initialized.</dd></dl>
<dl class="attention"><dt><b>Attention:</b></dt><dd>Trying to recursively lock a mutex from the same thread results in undefined behavior. Never lock recursively. </dd></dl>

</div>
</div>
<a class="anchor" id="af801a5957379c6a592479e7d3c6d4e47"></a><!-- doxytag: member="amp_mutex.h::amp_mutex_trylock" ref="af801a5957379c6a592479e7d3c6d4e47" args="(amp_mutex_t mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int amp_mutex_trylock </td>
          <td>(</td>
          <td class="paramtype">amp_mutex_t&nbsp;</td>
          <td class="paramname"> <em>mutex</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Locks the mutex or, if the mutex is already locked by another thread, returns with an error code.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>AMP_SUCCESS if the lock has been taken. AMP_BUSY if lock hasn't been taken because it is locked by another thread. Error codes might be returned to signal errors while trying to lock, too. These are programming errors and mustn't occur in release code. When <em>amp</em> is compiled without NDEBUG set it might assert that these programming errors don't happen. AMP_ERROR if the mutex isn't valid, e.g. not initialized or if trying to lock recursively.</dd></dl>
<dl class="attention"><dt><b>Attention:</b></dt><dd>Don't enter the critical section if an error code is returned because the lock hasn't been taken.</dd>
<dd>
Trying to recursively lock a mutex from the same thread results in undefined behavior. Never lock recursively. </dd></dl>

</div>
</div>
<a class="anchor" id="a358bd615b5a4c3015b8db7e7d2f8e325"></a><!-- doxytag: member="amp_mutex.h::amp_mutex_unlock" ref="a358bd615b5a4c3015b8db7e7d2f8e325" args="(amp_mutex_t mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int amp_mutex_unlock </td>
          <td>(</td>
          <td class="paramtype">amp_mutex_t&nbsp;</td>
          <td class="paramname"> <em>mutex</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unlocks the mutex, other threads trying to lock it or which are blocked waiting on the lock will get it in non-deterministic order one after the other afterwards.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>AMP_SUCCESS after successful unlocking. Error codes might be returned to signal errors while unlocking, too. These are programming errors and mustn't occur in release code. When <em>amp</em> is compiled without NDEBUG set it might assert that these programming errors don't happen. AMP_ERROR if the mutex isn't valid, e.g. not initialized or if a thread not holding the lock tries to unlock the mutex.</dd></dl>
<dl class="attention"><dt><b>Attention:</b></dt><dd>Only the thread holding the lock is allowed to unlock it, otherwise behavior is undefined.</dd>
<dd>
Trying to unlock an already unlocked mutex results in undefined behavior. </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Oct 12 2011 15:00:35 for FlightlessManacotti by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
